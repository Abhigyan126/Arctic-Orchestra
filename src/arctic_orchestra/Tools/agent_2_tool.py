class Agent2Tool:
    """
    Wrap an Agent instance into a tool-callable function for the new Agent system.

    This wrapper produces a Python function with:
    - A stable signature `(input: str)`
    - A docstring used as the tool description (LiteLLM reads this)
    - JSON schema auto-generated by Agent._build_tool_schemas()

    The wrapped function delegates all execution to `agent.run()`.
    """
    def __init__(self, agent, additional_prompt: str = ""):
        self.agent = agent
        self.tool_name = agent.name.replace(" ", "_").lower()
        self.additional_prompt = additional_prompt

    def create_tool(self):
        agent = self.agent
        tool_name = self.tool_name

        # Make description part of the docstring (THIS is what LiteLLM reads)
        description_text = (
            f"Delegates a sub-task to agent '{agent.name}'.\n\n"
            f"Identity:\n{agent.identity}\n\n"
        )

        if self.additional_prompt:
            description_text += f"Additional Instructions:\n{self.additional_prompt}\n"

        # -------- The callable tool --------
        def agent_tool(input: str):
            """
            {description}
            """.replace("{description}", description_text)

            # The new Agent expects direct execution here
            return agent.run(input)

        # Required for JSON schema generation
        agent_tool.__annotations__ = {"input": str}

        return tool_name, agent_tool
